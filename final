#include <EEPROM.h> //Need this library to access the on-chip EEPROM
byte left_speed = 100, right_speed = 100;\

//succ


/* Pinout schematic   




DIGITAL PINS: 

0. 
1. 
2. Left Bumper
3. Right Bumper
4. Motor Left Direction
5. Motor Left Speed
6. Motor Right Speed
7. Motor Right Direction 
8. Left Motor Encoder
9. Right Motor Encoder 
10. 
11. 
12. Push button to start program
13. LED 

ANALOG PINS: 
0. IR sensor Left 
1. IR sensor center
2. IR sensor right 

*/ 

#define leftBumper 2
#define rightBumper 3
#define leftDirection 4
#define leftSpeed 5
#define rightSpeed 6
#define rightDirection 7
#define leftEncoder 8
#define rightEncoder 9
#define button 12
#define LED 13

#define leftIR A0
#define centreIR A1
#define rightIR A2

bool LEFT = false;
bool RIGHT = true;

void setup(){
    Init();
    WaitButton();
    Serial.begin(9600);    
}

void Init(){
    pinMode(leftBumper, INPUT);
    pinMode(rightBumper, INPUT);
    pinMode(leftDirection, OUTPUT);
    pinMode(leftSpeed, OUTPUT);
    pinMode(rightSpeed, OUTPUT);
    pinMode(rightDirection, OUTPUT);
    pinMode(leftEncoder, INPUT);
    pinMode(rightEncoder, INPUT);
    pinMode(button, INPUT);
    pinMode(LED, OUTPUT);

    pinMode(leftIR, INPUT);
    pinMode(centreIR, INPUT);
    pinMode(rightIR, INPUT);
}

void WaitButton(){
    int read = 1; //force the while loop
    while(read){
        read = digitalRead(button); //will = 0 when button is pressed (button pulls down a LOW signal)
        Serial.println("Waiting for button...");
        delay(100);
    }

    digitalWrite(LED, HIGH);
    Serial.println("Program initiated!");
}

void loop(){
}

//Variables to use in the motor encoder
long countLeft = 0;
long countRight = 0;
int prevLeftRot = 0;
int prevRightRot = 0;


/*

** WE SHOULD SPLIT THIS FUNCTION UP INTO LEFT AND RIGHT SIDE> THIs WILL GIVE US FLEXIBILITY WITH DOING MORE COMPLICATED STUFF LIKE TURNING AT PRECISE ANGLES ***

*/

//Will run a while loop until the countLeft variable reaches or exceeds 'thresh'
void countEncoder(int thresh) {
  while (countLeft < thresh) {
    int rotLeft = digitalRead(leftEncoder); //gets the left and right encoder states
    int rotRight = digitalRead(rightEncoder); 

    if (rotLeft == 1 && rotLeft != prevLeftRot) { //If left rotor is transitioning to 1...
      countLeft++; //add one to the count
      digitalWrite(LED, HIGH); //turn led on
    }

    if (rotLeft == 0 && rotLeft != prevLeftRot) { //If left rotor is transitioning to 0...
      countLeft++; //add one to the count
      digitalWrite(LED, LOW); //turn the led off
    }

    if (rotRight == 1 && rotRight != prevRightRot) { //If right rotor is transitioning to 1...
      countRight++; //add one to count
    }
    
    if (rotRight == 0 && rotRight != prevRightRot) { //If right rotor is transitioning to 0...
      countRight++; //add one to count
    }
    
    prevLeftRot = rotLeft; //set the prev rotor vals to be the current ones (will be previous by next loop iteration)
    prevRightRot = rotRight;
  }
}

//Driving functions
void driveForward(int speed){
    digitalWrite(leftDirection, HIGH);
    digitalWrite(rightDirection, HIGH);

    analogWrite(leftSpeed, speed);
    analogWrite(rightSpeed, speed);
}//driveForward()

void driveBackward(int speed){
    digitalWrite(leftDirection, LOW);
    digitalWrite(rightDirection, LOW);
    analogWrite(leftSpeed, speed);
    analogWrite(rightSpeed, speed);
}//driveBackward()

void park(){
    analogWrite(leftSpeed, 0);
    analogWrite(rightSpeed, 0);
}//park()

void pivot(bool direction, int angle){
    int counter = 0;
    park();
    if(dir){ //turn right -- may want to double check this please 
        digitalWrite(rightDirection, HIGH);
        digitalWrite(leftDirection, LOW);
        analogWrite(leftSpeed, 100);
        analogWrite(rightSpeed, 100);
    } else { //turn left
        digitalWrite(rightDirection, LOW);
        digitalWrite(leftDirection, HIGH);
        analogWrite(leftSpeed, 100);
        analogWrite(rightSpeed, 100);
    }

    while(true){
        if(digitalRead(leftEncoder) == HIGH){
            counter++;
            delay(10);
        }
        if(counter >= angle*0.65){
            park();
            break;
        }
    }
}

void reactBumpers(){

    //Case 1: both bumpers hit
    if ((digitalRead(leftBumper) == LOW) && (digitalRead(rightBumper) == LOW)){
        park();
        delay(1500);
        driveBackward(150);
        delay(1500);
        pivot(LEFT, 180);
    } else if (digitalRead(leftBumper) == LOW){ //left bumper hits
        park();
        delay(1000);
        driveBackward(150);
        delay(1500);
        pivot(RIGHT, 45);
    } else if (digitalRead(rightBumper) == LOW){ //right bumper hits
        park();
        delay(1000);
        driveBackward(150);
        delay(1500);
        pivot(LEFT, 45);        
    } else {
        driveForward(150); //default case
    }
}

void countEncoder(int thresh) {
  while (countLeft < thresh) {
    int rotLeft = digitalRead(LEFT_ROT); //gets the left and right encoder states
    int rotRight = digitalRead(RIGHT_ROT); 
    if (rotLeft == 1 && rotLeft != prevLeftRot) { //If left rotor is transitioning to 1...
      countLeft++; //add one to the count
      digitalWrite(13, HIGH); //turn led on
    }
    if (rotLeft == 0 && rotLeft != prevLeftRot) { //If left rotor is transitioning to 0...
      countLeft++; //add one to the count
      digitalWrite(13, LOW); //turn the led off
    }
    if (rotRight == 1 && rotRight != prevRightRot) { //If right rotor is transitioning to 1...
      countRight++; //add one to count
    }
    if (rotRight == 0 && rotRight != prevRightRot) { //If right rotor is transitioning to 0...
      countRight++; //add one to count
    }
    prevLeftRot = rotLeft; //set the prev rotor vals to be the current ones (will be previous by next loop iteration)
    prevRightRot = rotRight;
  }
}


//This function is a little confusing, i think that these right_speed and left_speed have to match with our other functions
//for this function to work as expected. Should get looked at. 
void adjustSpeed(){
    if(digitalRead(leftBumper) == 0 || digitalRead(rightBumper) == 0){ 
        delay(500);
    }

    if(digitalRead(leftBumper) == 0 && digitalRead(rightBumper) == 1){ // with left bumper, go right more
        left_speed -= 2;
        right_speed += 2;
    }

    else if(digitalRead(rightBumper) == 0 && digitalRead(leftBumper) == 1){
        left_speed += 2;
        right_speed -= 2;
    }
  
    else if(digitalRead(leftBumper) == 0 && digitalRead(rightBumper) == 0){
        Serial.println(left_speed);
        Serial.println(right_speed);
    
        EEPROM.write(0, left_speed);
        EEPROM.write(1, right_speed);

        right_speed = left_speed = 0;
        delay(100);
    }
}//adjustSpeed()

